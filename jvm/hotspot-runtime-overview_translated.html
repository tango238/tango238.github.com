<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 5.7.0 (451010)"/><meta name="author" content="Go Tanaka"/><meta name="created" content="2014-11-01 05:54:42 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2014-11-05 14:51:22 +0000"/><title>hotspot-runtime-overview_translated</title>
<link rel="stylesheet" href="hotspot-runtime-overview_translated.css"
</head>
<body>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt;">
<div>The original document is the following URL.</div>
</div>
<div><a href="http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html">http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html</a></div>
<div><br/></div>
<div>License: GPLv2</div>
<div>
<hr/></div>
<div><br/></div>
<div style="font-size: 10pt; padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-right: 0pt; margin-bottom: 1ex; margin-top: 0ex; font-weight: bold;">
<div><span style="font-family: Verdana;"><span style="font-size: 10pt;">HotSpot Runtime Overview</span></span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;margin-bottom:0.2in;">
<div><span style="font-family: Verdana;">このセクションはHotSpotランタイムシステムの主要なサブシステムのキーコンセプトを紹介します。</span></div>
<div><span style="font-family: Verdana;">次のトピックを紹介します。</span></div>
</div>
<ul style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;padding-left:2em;list-style-type:square;">
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">コマンドライン引数の処理</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">VMのライフサイクル</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">VMのクラスローディング</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">バイトコードの検証とフォーマットチェック</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">クラスデータシェアリング (未翻訳)</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">インタプリタ (未翻訳)</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">Javaの例外処理 (未翻訳)</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">同期化(Synchronization) (未翻訳)</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">スレッド管理 (未翻訳)</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">C++ヒープ管理 (未翻訳)</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">Java Native Interface (JNI) (未翻訳)</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">VMの致命的な例外処理 (未翻訳)</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">参考 (未翻訳)</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">さらに読み進めるために (未翻訳)</span></li>
</ul>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex; font-weight: bold; font-size: 12px;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></div>
<div><span style="font-family: Verdana;">コマンドライン引数の処理</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><br/></div>
<div><span style="font-family: Verdana;">Java HotSpot仮想マシンの性能に影響を与えるたくさんのコマンドライン引数オプションや環境変数があります。これらの中のいくつかのオプションはランチャによって使用されるもの (例えば `-server` や `-client`) や、いくつかはランチャによって処理されJVMに渡されますが、ほとんどのオプションは直接JVMに渡されます。</span></div>
<div><span style="font-family: Verdana;"><br/></span></div>
<div><span style="font-family: Verdana;">オプションは主に３つのカテゴリがあります。標準オプション(standard option)、非標準オプション(non-standard option)、開発オプション(developer option)です。</span></div>
<div><span style="font-family: Verdana;">標準オプションは全てのJVM実装で利用可能かつリリース間でも安定しています。（depricatedになることはありますが）</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: Verdana;"><span style="font-size: 10pt;">-X</span> で始まるオプションは非標準オプション（全てのJVM実装でサポートされることが保証されていない）で、今後のJava SDKのリリースで予告なく変更される可能性があります。</span></div>
<div><span style="font-family: Verdana;"><span style="font-size: 10pt;">-XX</span> で始まるオプションは開発オプションで正常に動作させるためには特定のシステム要件が必要であったり、システム設定パラメータへのアクセス権限が必要であったりする場合もあります。このオプションは通常利用には推奨されていません。このオプションも予告なく変更されることがあります。</span></div>
<div><span style="font-family: Verdana;"><br/></span></div>
<div><span style="font-family: Verdana;">コマンドラインフラグはJVM内部の変数を扱います。それらは型がありデフォルト値を持っています。booleanの値はコマンドラインが扱うその変数の値が単に存在するかしないかを表します。 -XX のbooleanフラグの '+' や '-' の名前の前につくプレフィックスはそれぞれ true か false の値です。追加で情報が必要になる値は、その情報を(引数として)渡すことによって利用できる異なるメカニズムがあることを表します。いくつかのフラグは名前の後にとくに記号もなく直接データが渡されることもあります。一方で他のフラグは名前の後とデータを ':' や '=' で分けないといけないものがあります。残念なことにこの方法は特定のフラグやパース方法に依存しています。開発フラグ(-XXフラグ) は次の３つの異なった形しかありません。</span></div>
<div><font face="Courier New, monospace"><span style="font-size: 10pt;"><span style="font-family: Verdana;">「</span>-XX:+</span></font><font face="Courier New, monospace"><i><span style="font-size: 10pt;">OptionName</span></i></font><span style="font-family: Verdana;"><span style="font-size: 10pt;">」「</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-XX:-</span></font><font face="Courier New, monospace"><i><span style="font-size: 10pt;">OptionName</span></i></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">」<span style="font-family: Verdana;">そして</span><span style="font-family: Verdana;">「</span></span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-XX:</span></font><font face="Courier New, monospace"><i><span style="font-size: 10pt;">OptionName</span></i></font><font face="Courier New, monospace"><span style="font-size: 10pt;">=<span style="font-family: Verdana;">」です。</span></span></font></div>
<div><br/></div>
<div><span style="font-family: Verdana;">ほとんど全てのintegerサイズのオプションはサフィックスに 'k', 'm', 'g' が利用できます。それぞれキロ、メガ、ギガの単位で扱うために利用できます。これらの引数はよくメモリサイズを指定するときに使われます。</span></div>
</div>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex; page-break-before: always;">
<div><span style="font-size: 12px;"><b><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></b></span></div>
<div><span style="font-size: 12px;"><b><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">VMのライフサイクル</span></b></span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: Verdana;">このセクションではHotSpot VMのライフサイクルに付属するJavaランチャの概要について説明します。</span></div>
</div>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex; font-weight: bold; font-size: 11px;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></div>
<div><span style="font-family: Verdana;">ランチャ</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: Verdana;">Java Standard EditionにはいくつかのHotSpot VMランチャがあります。UnixやWindowsのJavaコマンドで通常利用するランチャは java や javaw コマンドです。javaws はネットワークベースのランチャなので混同しないようにしてください。</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><br/></div>
<div><span style="font-family: Verdana;">VM起動時にランチャは以下のように動作します：</span></div>
</div>
<ol style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;">
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">コマンドライン引数を解析します。</span><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">-client <span style="font-family: Verdana;">もしくは</span> </span><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">-server <span style="font-family: Verdana;">は適切なVMライブラリをロードするためにランチャ内で使用されます。その他の引数は</span> </span><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">JavaVMInitArgs </span><span style="font-family: Verdana;">経由でVMに渡されます。</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">ヒープサイズおよびコマンドラインで明示的に指定されていない場合はコンパイラタイプ(client/server)を確立します。</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">LD_LIBRARY_PATH、</span><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">CLASSPATH </span><span style="font-family: Verdana;">の環境変数を設定します。</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">Main-Classクラスがコマンドラインで指定されていない場合、JARのマニフェストファイルにある Main-Class の名前を読み込みます。</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;"><span style="font-family: Verdana;">新しく作成されたスレッド(最初にできたスレッドではない)内で</span> </span></span><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">JNI_CreateJavaVM <span style="font-family: Verdana;">を</span></span><span style="font-family: Verdana;">使用してVMを作成します。(備考: 最初にできたスレッドでVMを作成するとVMをカスタマイズすることによる性能劣化が大きくなります。例えばWindows上でのスタックサイズやその他の制約など)</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;">VMが作成,初期化され、Main-Classが読み込まれるとランチャはMain-Classからメインメソッドの属性を取得します。</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">VM内で </span><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">CallStaticVoidMethod <span style="font-family: Verdana;">とコマンドラインに渡された</span></span><span style="font-family: Verdana;"><span style="text-align: left; float: none;">引数を使用して</span><span style="font-size: 10pt;">メインメソッドが</span>呼び出されます。</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-family: Verdana;">メインメソッド実行完了後、(とても重要なことに) 発生したペンディング中の例外をチェック、クリアし、exitステータスを返却します。例外は</span> </span><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">ExceptionOccurred </span><span style="font-family: Verdana;">を呼び出すことでクリアします。メソッドが成功の場合は戻り値が0になり、さもなければその他の値は呼び出し元のプロセスに返却されます。</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-family: Verdana;">メインスレッドは</span> </span><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">DetachCurrentThread <span style="font-family: Verdana;">で</span></span><span style="font-family: Verdana;">デタッチされます。デタッチするとスレッドカウントをデクリメントします。これにより </span><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">DestroyJavaVM</span><span style="font-family: Verdana;">を安全に呼び出すことができ、かつスレッドが VM内の操作を実行していないことや JVM上のスタックにJavaフレームが存在しないことを保証します。</span></li>
</ol>
<div style="padding:0pt;margin:1ex 0em;">
<div><br/></div>
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">一番重要なフェーズは </span><font face="Courier New, monospace"><font size="3">JNI_CreateJavaVM</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"> と </span><font face="Courier New, monospace"><font size="3">DestroyJavaVM </font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">です。これらについて次のセクションで説明します。</span></div>
</div>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex; font-weight: bold; font-size: 11px;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">JNI_CreateJavaVM</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">JNI</span></span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">の呼び出しメソッドは次のように実行します</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">:</span></span></div>
</div>
<ol style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;">
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;"><span style="font-size: 10pt;">２つのスレッドが同時にこのメソッドを呼び出していないことや２つのVMインスタンスが同じプロセスで作成されていないことを保証します。初期化時に "point of no return" に到達すると同じプロセス空間にVMを作成することができなくなります。これはこのときVMが再度初期化できない静的データ構造を作成するためです。</span></span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;"><span style="font-size: 10pt;">JNIのバージョンがサポートされているか確認し、GCロギングのためにostreamが初期化されます。乱数生成器、現在のpid、高精度計時、メモリーページサイズやガードページなどの</span><span style="font-size: 10pt;">OSモジュールが初期化されます。</span></span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;"><span style="font-size: 10pt;">後で使用するためにパースされ保存されていた引数やプロパティが渡されます。一般的な</span><span style="font-size: 10pt;">Javaのシステムプロパティが初期化されます。</span></span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;"><span style="font-size: 10pt;">同期化やスタックメモリ、セーフポイントページのためにパースされた引数やプロパティを基にしたOSモジュールが作成され初期化されます。このとき libzip、libhpi、libjava、libthreadが読み込まれ、シグナルハンドラが初期化され設定されます。そしてスレッドライブラリが初期化されます。</span></span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;"><span style="font-size: 10pt;">出力ストリームロガーが初期化されます。必要とされるすべてのエージェントライブラリ(hprofやjdi)が初期化され開始されます。</span></span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;"><span style="font-size: 10pt;">スレッドの操作のために必要ないくつかのスレッドの</span><span style="font-size: 10pt;">特定のデータを保持するスレッド状態</span><span style="font-size: 10pt;">や</span>スレッド局所記憶<span style="font-size: 10pt;">(TLS)</span><span style="font-size: 10pt;">が初期化されます。</span></span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: Verdana;"><span style="font-size: 10pt;">イベントログ、OS </span><span style="font-size: 10pt;">synchronization primitives, perfMemory (performance memory), chunkPool (memory allocator)などの Iフェーズのグローバルデータが初期化されます。</span></span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">このとき </span></span><font face="Courier New, monospace"><font size="3">Threads <span style="font-family: Verdana;">を作成できるようになります。メインスレッドのJavaバージョンが作成され現在のOSスレッドにアタッチされます。しかしこのスレッドはまだ </span></font></font><font face="Courier New, monospace"><font size="3">Threads <span style="font-family: Verdana;">の known list には追加されていません。Javaレベルの同期化は初期化、有効化されます。</span></font></font></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><font face="Courier New, monospace" style="text-align: left;"><font size="3">BootClassLoader</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica; text-align: left; float: none;">, </span><font face="Courier New, monospace" style="text-align: left;"><font size="3">CodeCache</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica; text-align: left; float: none;">, </span><font face="Courier New, monospace" style="text-align: left;"><font size="3">Interpreter</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica; text-align: left; float: none;">, </span><font face="Courier New, monospace" style="text-align: left;"><font size="3">Compiler</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica; text-align: left; float: none;">, JNI,</span><font face="Courier New, monospace" style="text-align: left;"><font size="3">SystemDictionary</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica; text-align: left; float: none;">,</span><font face="Courier New, monospace" style="text-align: left;"><font size="3">Universeなどの</font></font>残りのグローバルモジュールが初期化されます。"point of no return <span style="font-size: 10px;">(もはや後に引けない段階)</span>"に到達し、同じプロセスのアドレス空間に他のVMを作成することができなくなります。</li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">Thread_Lock</span>を初めてロックしてメインスレッドがリストに追加されます。<span style="text-align: left; float: none;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Universe（必要となるグローバルデータ構造のセット）</span>の安全性チェックが行われ、VMの全ての重要な機能を実行する </span><span style="text-align: left; float: none;"><span style="font-family: 'Courier New', monospace;">VMThread </span>が作成されます。このとき、適切なJVMTIイベントが現在の状態を通知するために送信されます。</span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.String</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">,</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.System</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">,</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">,</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.ThreadGroup</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">,</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.reflect.Method</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">,</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.ref.Finalizer</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">,</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Classやその他のシステムクラスが読み込まれ初期化されます。このとき、VMは初期化され使用可能になります。しかしまだ完全には機能していません。</font></font></li>
<li style="margin-top:0pt;margin-bottom:0pt;">シグナルハンドラスレッドが開始され、コンパイラが初期化されCompileBrokerスレッドが開始されます。<span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica; text-align: left; float: none;"> StatSampler and WatcherThreads のヘルパースレッドも開始される。このときVMの全ての機能が使用できるようになり、</span><span style="text-align: left; float: none;"><span style="font-family: 'Courier New', monospace;">JNIEnv が設定され呼び出し元に返され、</span>VMはJNIリクエストを受け付ける準備が整います。</span></li>
</ol>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex;">
<div><b><span style="font-size: 11px;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">DestroyJavaVM</span></span></b></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div>このメソッドはVMを終了するためにランチャから呼び出されます。またとても深刻なエラーが発生したときにVM自身からも呼び出されます。</div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">VMの終了は次のようなステップ行います:</span></span></div>
</div>
<ol style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;">
<li style="margin-top:0pt;margin-bottom:0pt;">最後のデーモンではないスレッドが実行するまで待ちます。VMはまだ機能しています。</li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="text-align: left; float: none;"><span style="font-family: 'Lucida Sans Typewriter', monospace;">java.lang.Shutdown.shutdown() </span>を呼び出します。このメソッドはJavaレベルのshutdown hookの呼び出しや finalization-on-exit のときにfinalizerを実行します。</span></li>
</ol>
<ol start="2" style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;">
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="text-align: left; float: none;">VMレベルのshutdown hooks</span><span style="text-align: left; float: none;">(</span><span style="font-family: 'Courier New', monospace; text-align: left; float: none;">JVM_OnExit()に登録されている</span><span style="text-align: left; float: none;">)</span><span style="text-align: left; float: none;">に備えるために</span><span style="text-align: left; float: none;"><span style="font-family: 'Courier New', monospace;">before_exit()</span>を実行ます。</span><font face="Courier New, monospace" style="text-align: left;"><font size="3">Profiler</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica; text-align: left; float: none;">,</span><font face="Courier New, monospace" style="text-align: left;"><font size="3">StatSampler</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica; text-align: left; float: none;">, </span><font face="Courier New, monospace" style="text-align: left;"><font size="3">Watcher</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica; text-align: left; float: none;"> and </span><font face="Courier New, monospace" style="text-align: left;"><font size="3">GC</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica; text-align: left; float: none;">スレッドを停止します。ステータスイベントを</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica; text-align: left; float: none;">JVMTI/PIに送信し、JVMPIを無効化、シグナルスレッドを停止します。</span></li>
</ol>
<ol start="3" style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;">
<li style="margin-top:0pt;margin-bottom:0pt;"><font face="Courier New, monospace"><font size="3">JavaThread::exit()を呼び出して<span style="font-family: Verdana;">JNIハンドルブロックを解放、</span>スタックガードページ</font></font>を削除、スレッドリストからこのスレッドを削除します。このときからあらゆるJavaコードは実行できなくなります。</li>
<li style="margin-top:0pt;margin-bottom:0pt;">VMスレッドを停止するとVMをsafe pointに持ってきてコンパイラスレッドを停止します。safe pointでは"Safepoint"によりブロックされるので何も利用することができません。</li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">JNI/JVM/JVMPIバリアでトレースを無効化します。</span></span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">まだ実行しているネイティブコードのスレッドのために </span></span><font face="Courier New, monospace"><font size="3">_vm_exited フラグを設定します。</font></font></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">このスレッドを削除します。</span></span></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><font face="Courier New, monospace"><font size="3">exit_globals()</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">を呼び出して、</span></span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">IO や </span></span><font face="Courier New, monospace"><font size="3">PerfMemoryリソースを削除します。</font></font></li>
<li style="margin-top:0pt;margin-bottom:0pt;"><span style="font-family: 'Courier New', monospace;">呼び出し元に返します。</span><br/></li>
</ol>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex;">
<div><b><span style="font-size: 12px;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></span></span></b></div>
<div><span style="font-size: 12px;"><b><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">VMのクラスローディング</span></b></span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Java HotSpot VMはJava言語仕様第３版</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">[1]、Java仮想マシン仕様(JVMS)第２版[2] や更新されたJVMSの第５章の "</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Loading, Linking and Initializing</span></span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">"[3] の修正版で</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">定義されたクラスローディングをサポートします。</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">VMは</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">クラスやインターフェースのローディング、リンク、初期化が必要になる</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">コンスタントプールのシンポルの解決を行います。"クラスローディング"という用語はクラスやインターフェース名とクラスオブジェクトのマッピングやJVMSのクラスローディングのフェーズで定義されたより具体的なローディング、リンク、初期化といった全体的なプロセスのことをいいます。</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">一般的なクラスローディングはクラスファイルの中のコンスタントプールのシンボルを解決するときのバイトコード解決のことをいいます。</span><font face="Lucida Sans Typewriter, monospace"><font size="3">Class.forName()</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">,</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">classLoader.loadClass()</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">, reflection APIs や </span></span><font face="Courier New, monospace"><font size="3">JNI_FindClass <span style="font-family: Verdana;">といったJava APIはクラスローディングの初期化を行うことができます。VM自身もクラスローディングの初期化を行うことができます。VMは </span></font></font><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Object</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">,</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread <span style="font-family: Verdana;">などのコアクラスをJVM起動時に読み込みます。クラスを読み込むときはそのクラスのすべての親クラス、親インターフェースを読み込む必要があります。またリンクフェーズのクラスファイルの検証ではさらに追加してクラスの読込みが必要になります。</span></font></font></div>
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">VMやJava SEのクラスローディングライブラリはどちらもクラスローディングの責務を共有します。VMはコンスタントプール解決、リンクやクラスやインターフェースの初期化を行います。ローディングフェーズはVMと特定のクラスローダ</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">(</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.classLoader</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">)</span></span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">の協業で行います。</span></div>
</div>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex; font-weight: bold; font-size: 11px;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></div>
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">クラスローディングフェーズ</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">"ロードクラス</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">"</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">フェーズでは クラスやインターフェースの名前を取得しクラスファイルのフォーマットからバイナリを探し、クラスを定義して </span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Class オブジェクトを作成します。</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">ロードクラスフェーズ</span><font face="Lucida Sans Typewriter, monospace"><font size="3">ではバイナリ表現が見つからなかった場合 </font></font><font face="Lucida Sans Typewriter, monospace"><font size="3">NoClassDefFound <span style="font-family: Verdana;">エラーを</span></font></font><font face="Lucida Sans Typewriter, monospace"><font size="3">送出しま</font></font><font face="Lucida Sans Typewriter, monospace"><font size="3"><span style="font-family: Verdana;">す。さらに</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">ロードクラスフェーズ</span><font face="Lucida Sans Typewriter, monospace"><font size="3"><span style="font-family: Verdana;">ではクラスファイルシンタックスのフォーマットチェック時に </span></font></font><font face="Lucida Sans Typewriter, monospace"><font size="3">ClassFormatError</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;"> や </span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">UnsupportedClassVersionError を送出します。クラスのロードが完了する前に、VMはすべての親クラスと親インターフェースをロードします。もし再帰的に取得した親クラスや親インターフェースに問題があれば、VMは </font></font><font face="Lucida Sans Typewriter, monospace"><font size="3">ClassCircularityError</font></font><font face="Lucida Sans Typewriter, monospace"><font size="3"> を送出します。また親インターフェースがインターフェースではなかった場合や、親クラスがインターフェースだった場合、VMは</font></font><font face="Lucida Sans Typewriter, monospace"><font size="3">IncompatibleClassChangeError</font></font><font face="Lucida Sans Typewriter, monospace"><font size="3"> を送出します。</font></font></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></div>
<div><span style="font-family: Verdana;">"リンククラス"フェーズは最初にクラスファイルのセマンティクスのチェック、コンスタントプールシンボルのチェックや型チェックといった検証を行います。これらのチェック時に </span><font face="Lucida Sans Typewriter, monospace"><font size="3">VerifyError <span style="font-family: Verdana;">を送出します。リンキングは静的フィールドを作成しデフォルト値で初期化、メソッドテーブルの割当といった準備をします。ここではまだJavaコードは実行されません。リンキングは任意でシンボリック参照の解決を行います。</span></font></font></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></div>
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">クラス初期化</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">処理</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">では静的初期化子と静的フィールドの初期化子を実行します。これがこのクラスで初めて実行されるJavaコードになります。クラス初期化</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">処理</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">は親インターフェースの初期化ではなく親クラスの初期化が必要になります。</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></div>
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">JVMS(Java仮想マシン仕様)ではクラス初期化処理はクラスの初めての利用時に発生すると記載されています。JLS(Java言語仕様)は、その言語セマンティクスに従っている限りはリンキング時のシンボリック解決に関しては柔軟でローディング、(</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">次のステップを実行する前の)</span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">リンキングや初期化のそれぞれのステップで完了して(プログラムが期待する)エラーを送出します。パフォーマンスの点ではHotSpot VMは一般的にクラス初期化処理をしクラスのロードとリンクが完了するまで待ちます。もしクラスAがクラスBを参照し、クラスAのローディングは(クラスの検証は必要になるのは除き)クラスBのローディングは必要になりません。Bを参照する初めての命令の実行はクラスBのローディングやリンキングが必要になるBの初期化処理を引き起こします。</span></div>
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></div>
</div>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex; font-weight: bold; font-size: 11px;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">クラスローダの委譲</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: Verdana;">クラスローダがクラスの検索とロードを要求されるとき、そのクラスローダは実際のローディングを他のクラスローダへ要求します。これはクラスローダの委譲と呼ばれます。最初のローダは初期化ローダ(initiating loader)で最終的に暮らすを定義するクラスローダは定義ローダ(defining loader)といいます。バイトコード解決では、初期化ローダはクラスのコンスタントプールシンボルを解決するクラスローダです。</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: Verdana;">クラスローダは階層構造で定義されておりそれぞれのクラスローダは委譲する親をもちます。委譲はバイナリのクラス表現の検索順を定義します。Java SEのクラスローダの階層構造は bootstrapクラスローダ、extensionクラスローダ、systemクラスローダの順に探します。systemクラスローダはデフォルトのアプリケーションクラスローダで、"main"を実行しクラスパスからクラスをロードします。アプリケーションクラスローダはJava SEクラスローダライブラリのクラスローダにもなりますし、アプリケーション開発者から提供されたりもします。Java SEクラスローダライブラリはJREのlib/extディレクトリからクラスをロードするextensionクラスローダを実装します。</span></div>
</div>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex; font-weight: bold; font-size: 11px;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></div>
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Bootstrapクラスローダ</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-family: Verdana;">VMは例えばrt.jarを含む</span> </span><font face="Courier New, monospace"><span style="font-size: 10pt;">BOOTPATH </span></font><span style="font-family: Verdana;">からクラスをロードするbootstrapクラスローダを実装します。さらに速く起動するためにVMはクラスデータの共有(Class Data Sharing)を利用して事前にロードしされたクラスも処理します。</span></div>
</div>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex; font-weight: bold; font-size: 11px;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></div>
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">型安全</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: Verdana;">クラスやインターフェースの名前はパッケージ名を含んだ完全に修飾された名前で定義されます。クラスの型はその完全に修飾された一意となる名前とクラスローダから決定します。なのでクラスローダは名前空間を定義し、２つの異なるクラスローダからロードされた同じクラス名は異なるクラスの型になります。</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: Verdana;">カスタムクラスローダの存在を考えると、VMは行儀の悪いクラスローダが型の安全性に違反しないことを保証する責任があります。"Dynamic Class Loading in the Java Virtual Machine"[4] や　JVMS 5.3.4[2] を参照してください。VMは、クラスA が B.foo() を呼び出したときに、AのクラスローダとBのクラスローダがfooのパラメータについて合意し、追跡し、ローダ制約をチェックすることで、値を返すことが保証されます。</span></div>
</div>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex; font-weight: bold; font-size: 11px;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></div>
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">HotSpotのクラスのメタデータ</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-family: Verdana;">クラスローディング</span>は </span><font face="Courier New, monospace"><font size="3">instanceKlass や </font></font><font face="Courier New, monospace"><font size="3">arrayKlass を</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">GCのパーマネント領域に生成します。<span style="font-family: Verdana;">instanceKlass は</span></span><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-family: Verdana;">このクラスをミラーリングした</span> </span><font face="Courier New, monospace"><span style="font-size: 10pt;">java.lang.Class のインスタンスであ<span style="font-family: Verdana;">る</span></span></font><span style="font-family: Verdana;">Javaミラーを参照します。VMのC++は </span><font face="Courier New, monospace"><font size="3">klassOop <span style="font-family: Verdana;">経由で </span></font></font><font face="Courier New, monospace"><font size="3">instanceKlass </font></font><font face="Courier New, monospace"><font size="3"><span style="font-family: Verdana;">にアクセスします。</span></font></font></div>
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></div>
</div>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex; font-weight: bold; font-size: 11px;">
<div><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">HotSpot Internal Class Loading Data</span></div>
</div>
<div style="padding:0pt;margin:1ex 0em;">
<div>HotSpot VMは、クラスのロードを追跡するために、3つの主要なハッシュテーブルを扱います。<font face="Courier New, monospace"><font size="3">SystemDictionary に</font></font>は <font face="Courier New, monospace"><font size="3">klassOop</font></font> に紐づいたクラス名/クラスローダのペアのロードされたクラスが含まれています。<font face="Courier New, monospace"><font size="3">SystemDictionary には"クラス名/初期化ローダ"および"クラス名/定義ローダ"のペア</font></font>が含まれています。エントリは現在はsafepointでのみ削除されます。<font face="Courier New, monospace"><font size="3">PlaceholderTable <span style="font-family: Verdana;">は現在までにロードされたクラスを含みます。これは </span></font></font><font face="Lucida Sans Typewriter, monospace"><font size="3">ClassCircularityError</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">checking</span></span> <font face="Courier New, monospace"><font size="3"><span style="font-family: Verdana;">やマルチスレッドクラスドーディングをサポートしたクラスローダの並列クラスローディングに使用されます。</span></font></font><font face="Courier New, monospace"><font size="3">LoaderConstraintTable <span style="font-family: Verdana;">は型安全チェックの制約を追跡します。</span></font></font></div>
</div>
<div style="padding-top: 0pt; padding-right: 0pt; padding-bottom: 0pt; padding-left: 0pt; margin-top: 1.5ex; margin-right: 0pt; margin-bottom: 1ex;">
<div>これらのハッシュテーブルは、すべて <font face="Courier New, monospace"><font size="3">SystemDictionary_lock </font></font>により保護されています。一般的に、VM内のロードクラスフェーズでは、クラスローダオブジェクトのロック(the <span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Class loader object lock</span></span>)を使用して直列化されています。<b><span style="font-size: 12px;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><br/></span></span></b></div>
<div><font face="'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica" size="2"><span style="line-height: 17px;"><b><br/></b></span></font></div>

<div><span style="font-size: 12px;"><b><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Bytecode Verifier and Format Checker</span></b></span></div>
</div>

<div>
  <p>
    <!-- The Java language is a type-safe language, and standard Java compilers produce valid classfiles and type-safe code,
	 but the JVM can't guarantee that the code was produced by a trustworthy compiler,
	 so it must reestablish that type-safety through a process at link-time called bytecode verification.
       -->
    <span>
      Java言語は型安全な言語なので、標準的なJavaコンパイラが生成するのは有効なクラスファイルと型安全なバイトコードです。
      しかし、JVMにはバイトコードが信頼できるコンパイラによって生成されたか分かりません。
      そこで、リンク時のバイトコード検証(bytecode verification)という処理により、バイトコードの型安全性を再び担保することが必要になります。
    </span>
  </p>
  <p>
    <!-- Bytecode verification is specified in section 4.8 of the Java Virtual Machine Specification.
	 The specification prescribes both static and dynamic constraints on the code which the JVM verifies.
	 If any violations are found, the VM will throw a VerifyError and prevent the class from being linked.
       -->
    <span>
	バイトコード検証の仕様は、Java仮想マシン仕様書の4.8節で規定されています。
	この仕様では、バイトコードにおいてJVMが検証を行う静的制約(static constraint)と動的制約(dynamic constraint)の両方が規定されています。
	制約に対する違反が見つかった場合、VMはVerifyError例外を発生させ、そのバイトコードを含むクラスがリンクされないようにします。
    </span>
  </p>
  <p>
    <!-- Many of the constraints on the bytecodes can be checked statically,
	 such as the operand of an ‘ldc’code must be a valid constant pool index whose type is CONSTANT_Integer, CONSTANT_Stringor CONSTANT_Float.
	 Other constraints which check the type and number of arguments for other instructions requires dynamic analysis of the code to determine which operands will be present on the expression stack during execution.
       -->
    <span>
      バイトコードに対する制約の多くは、静的に検証することが可能です。
      例えば、
      ‘<span class="emphasis-code-1">ldc</span>'
      命令のオペランドは
      <span class="emphasis-code-1">CONSTANT_Integer</span>
      、
      <span class="emphasis-code-1">CONSTANT_String</span>
      か
      <span class="emphasis-code-1">CONSTANT_Float</span>
      のいずれかの型を持つ、
      有効なコンスタントプールのインデックスでなくてはならないという制約などです。
      命令の引数の型と数についての制約で、バイトコードを動的に解析することが必要なものもあります。
      どういうオペランドが式スタック上に存在するか実行時でないと決定できないためです。
    </span>
  </p>
  <p>
    <!-- There are currently two methods of analyzing the bytecodes to determine the types and number of operands that will be present for each instruction.
	 The traditional method is called “type inference”,
	 and operates by performing an abstract interpretation of each bytecode and merging type states at branch targets or exception handles.
	 The analysis iterates over the bytecode until a steady state for the types are found.
	 If a steady state cannot be found, or if the resulting types violate some bytecode constraint,
	 then a VerifyError is thrown.
	 The code for this verification step is present in the libverify.so external library,
	 and uses JNI to gather whatever information is needed about classes and types.
       -->
    <span>
      現在二つの手法が、バイトコードを解析し、各命令のオペランドの型と数を決定するために用いられています。
      従来用いられていた手法は「型推論(type inference)」と呼ばれます。
      これは各バイトコードを抽象実行し、分岐命令のジャンプ先や例外ハンドルにおいて型情報を単一化することで動作します。
      解析では、型情報が確定するまで何度もバイトコードが走査されます。
      型情報を確定できない場合や、結果として得られた型がバイトコードの制約に違反している場合、
      <span class="emphasis-code-1">VerifyError</span>
      が発生します。
      この従来の検証手法は、外部ライブラリ
      <span class="emphasis-code-2">libverify.so</span>
      に含まれているため、クラスや型について必要な情報を収集するためにJNIを使用します。
    </span>
  </p>
  <p>
    <!-- New in JDK6 is the second method for verification which is called “type verification”.
	 In this method the Java compiler provides the steady-state type information for each branch or exception target, via the code attribute, StackMapTable.
	 The StackMapTable consists of a number of stack map frames,
	 each which indicates the types of the items on the expression stack and in the local variables at some offset in the method.
	 The JVM needs to then only perform one pass through the bytecode to verify the correctness of the types to verify the bytecode.
	 This is the method already used by JavaME CLDC.
	 Since it it smaller and faster, this method of verification is built directly in the VM itself.
       -->
    <span>
      JDK6において新しく導入された２つ目の検証手法は「型検証(type verification)」と呼ばれます。
      この方法ではまずJavaコンパイラが、分岐命令のジャンプ先および例外処理ごとに型情報を確定し、
      <span class="emphasis-code-1">StackMapTable</span>
      という属性としてバイトコードに付与します。
      <span class="emphasis-code-1">StackMapTable</span>
      はいくつかのスタックマップフレームから構成されており、それぞれのフレームはメソッド内のある位置における式スタックの要素およびローカル変数の型を含みます。
      その後JVMがバイトコードを一度だけ走査し、型の正しさを検証すればバイトコードの検証は完了です。
      この検証手法はJavaME CLDCですでに採用されています。
      この手法の処理は軽量で高速なため、VMの内部に実装されています。
    </span>
  </p>
  <p>
    <!-- For all classfiles with a version number less than 50, such as those created prior to JDK6,
	 the JVM will use the traditional type inference method to verify the classfiles.
	 For classfiles greater than or equal to 50,
	 the StackMapTable attributes will be present and the new verifier will be used.
	 Because of the possibility of older external tools that might instrument the bytecode but neglect to update the StackMapTable attribute,
	 certain verification errors that occur during type-checking verification may failover to the type-inference method.
	 Should that pass succeed, the class file will be verified.
       -->
    <span>
      JDK6より前に作成された場合など、バージョンが50未満のすべてのクラスファイルは、JVMは従来の手法である型推論を用いてクラスファイルを検証します。
      バージョンが50以上のクラスファイルには
      <span class="emphasis-code-1">StackMapTable</span>
      属性が存在するため、新しい検証手法である型検証が用いられます。
      古い外部ツールは、バイトコードを操作したのにもかかわらず、
      <span class="emphasis-code-1">StackMapTable</span>
      属性を更新しないことがありうるので、新しい手法である型検証を実施している際にエラーが発生するかもしれません。
      そのときは従来の手法である型推論に切り替わります。
      解析処理が成功して終了すれば、クラスファイルの検証は終わりです。
    </span>
  </p>

  <h3 style="font-size:9pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Class Data Sharing</span></h3>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Class data sharing (CDS) is a feature introduced in J2SE 5.0 that is intended to reduce the startup time for Java programming language applications, in particular smaller applications, as well as reduce footprint. When the JRE is installed on 32-bit platforms using the Sun provided installer, the installer loads a set of classes from the system jar file into a private internal representation, and dumps that representation to a file, called a “shared archive”. If the Sun JRE installer is not being used, this can be done manually, as explained below. During subsequent JVM invocations, the shared archive is memory-mapped in, saving the cost of loading those classes and allowing much of the JVM's metadata for these classes to be shared among multiple JVM processes.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Class data sharing is supported only with the Java HotSpot Client VM, and only with the serial garbage collector.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The primary motivation for including CDS is the decrease in startup time it provides. CDS produces better results for smaller applications because it eliminates a fixed cost: that of loading certain core classes. The smaller the application relative to the number of core classes it uses, the larger the saved fraction of startup time.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The footprint cost of new JVM instances has been reduced in two ways. First, a portion of the shared archive, currently between five and six megabytes, is mapped read-only and therefore shared among multiple JVM processes. Previously this data was replicated in each JVM instance. Second, since the shared archive contains class data in the form in which the Java Hotspot VM uses it, the memory which would otherwise be required to access the original class information in</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">rt.jar</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">is not needed. These savings allow more applications to be run concurrently on the same machine. On Microsoft Windows, the footprint of a process, as measured by various tools, may appear to increase, because a larger number of pages are being mapped in to the process' address space. This is offset by the reduction in the amount of memory (inside Microsoft Windows) which is needed to hold portions on</span></span><font face="Courier New, monospace"><font size="3">rt.jar</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">. Reducing footprint remains a high priority.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">In HotSpot, the class data sharing implementation introduces new Spaces into the permanent generation which contain the shared data. The classes.jsa shared archive is memory mapped into these Spaces at VM startup. Subsequently, the shared region is managed by the existing VM memory management subsystem.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Read-only shared data includes constant method objects (</span></span><font face="Courier New, monospace"><font size="3">constMethodOops</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">), symbol objects (</span></span><font face="Courier New, monospace"><font size="3">symbolOops</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">), and arrays of primitives, mostly character arrays.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Read-write shared data consists of mutable method objects (</span></span><font face="Courier New, monospace"><font size="3">methodOops</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">), constant pool objects (</span></span><font face="Courier New, monospace"><font size="3">constantPoolOops</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">), VM internal representation of Java classes and arrays (</span></span><font face="Courier New, monospace"><font size="3">instanceKlass</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">es and</span></span><font face="Courier New, monospace"><font size="3">arrayKlass</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">es), and various</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">String</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">,</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">Class</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">, and</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">Exception</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">objects.</span></span></p>
<h3 style="font-size:9pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Interpreter</span></h3>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The current HotSpot interpreter, which is used for executing bytecodes, is a template based interpreter. The HotSpot runtime a.k.a.</span></span><font face="Courier New, monospace"><font size="3">InterpreterGenerator</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">generates an interpreter in memory at the startup using the information in the</span></span><font face="Courier New, monospace"><font size="3">TemplateTable</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">(assembly code corresponding to each bytecode). A template is a description of each bytecode. The</span></span><font face="Courier New, monospace"><font size="3">TemplateTable</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">defines all the templates and provides accessor functions to get the template for a given bytecode. The non-product flag</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-XX:+PrintInterpreter</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">can be used to view the template table generated in memory during the VM's startup process.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The template design performs better than a classic switch-statement loop for several reasons. First, the switch statement performs repeated compare operations, and in the worst case it may be required to compare a given command with all but one bytecodes to locate the required one. Second, it uses a separate software stack to pass Java arguments, while the native C stack is used by the VM itself. A number of JVM internal variables, such as the program counter or the stack pointer for a Java thread, are stored in C variables, which are not guaranteed to be always kept in the hardware registers. Management of these software interpreter structures consumes a considerable share of total execution time.[5]</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Overall, the gap between the VM and the real machine is significantly narrowed by the HotSpot interpreter, which makes the interpretation speed considerably higher. This, however, comes at a price of e.g. large machine-specific chunks of code (roughly about 10 KLOC (thousand lines of code) of Intel-specific and 14 KLOC of SPARC-specific code). Overall code size and complexity is also significantly higher, since e.g. the code supporting dynamic code generation is needed. Obviously, debugging dynamically generated machine code is significantly more difficult than static code. These properties certainly do not facilitate implementation of runtime evolution, but they don’t make it infeasible either.[5]</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The interpreter calls out to the VM runtime for complex operations (basically anything too complicated to do in assembly language) such as constant pool lookup.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The HotSpot interpreter is also a critical part of the overall HotSpot adaptive optimization story. Adaptive optimization solves the problems of JIT compilation by taking advantage of an interesting program property. Virtually all programs spend the vast majority of their time executing a minority of their code. Rather than compiling method by method, just in time, the Java HotSpot VM immediately runs the program using an interpreter, and analyzes the code as it runs to detect the critical hot spots in the program. Then it focuses the attention of a global native-code optimizer on the hot spots. By avoiding compilation of infrequently executed code (most of the program), the Java HotSpot compiler can devote more attention to the performance-critical parts of the program, without necessarily increasing the overall compilation time. This hot spot monitoring is continued dynamically as the program runs, so that it literally adapts its performance on the fly to the user's needs.</span></span></p>
<h3 style="font-size:9pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Java Exception Handling</span></h3>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Java virtual machines use exceptions to signal that a program has violated the semantic constraints of the Java language. For example, an attempt to index outside the bounds of an array will cause an exception. An exception causes a non-local transfer of control from the point where the exception occurred (or was</span><i><span style="font-size: 10pt;">thrown</span></i><span style="font-size: 10pt;">) to a point specified by the programmer (or where the exception is</span><i><span style="font-size: 10pt;">caught)</span></i><span style="font-size: 10pt;">.[6]</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The HotSpot interpreter, dynamic compilers, and runtime all cooperate to implement exception handling. There are two general cases of exception handling: either the exception is thrown or caught in the same method, or it's caught by a caller. The latter case is more complicated and requires</span><i><span style="font-size: 10pt;">stack unwinding</span></i><span style="font-size: 10pt;">to find the appropriate handler.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Exceptions can be initiated by the</span><i><span style="font-size: 10pt;">throw</span></i><span style="font-size: 10pt;">bytecode, a return from a VM-internal call, a return from a JNI call, or a return from a Java call. (The last case is really just a later stage of the first 3.) When the VM recognizes that an exception has been thrown, the runtime system is invoked to find the nearest handler for that exception. Three pieces of information are used to find the handler; the current method, the current bytecode, and the exception object. If a handler is not found in the current method, as mentioned above, the current activation stack frame is popped and the process is iteratively repeated for previous frames.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Once the correct handler is found, the VM execution state is updated, and we jump to the handler as Java code execution is resumed.</span></span></p>
<h3 style="font-size:9pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Synchronization</span></h3>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Broadly, we can define “synchronization” as a mechanism that prevents, avoids or recovers from the inopportune interleavings (commonly called “races”) of concurrent operations. In Java, concurrency is expressed through the thread construct. Mutual exclusion is a special case of synchronization where at most a single thread is permitted access to protected code or data.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">HotSpot provides Java monitors by which threads running application code may participate in a mutual exclusion protocol. A monitor is either locked or unlocked, and only one thread may own the monitor at any one time. Only after acquiring ownership of a monitor may a thread enter the critical section protected by the monitor. In Java, critical sections are referred to as "synchronized blocks", and are delineated in code by the</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">synchronized</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">statement.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">If a thread attempts to lock a monitor and the monitor is in an unlocked state, the thread will immediately gain ownership of the monitor. If a subsequent thread attempts to gain ownership of the monitor while the monitor is locked that thread will not be permitted to proceed into the critical section until the owner releases the lock and the 2nd thread manages to gain (or is granted) exclusive ownership of the lock.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Some additional terminology: to “enter” a monitor means to acquire exclusive ownership of the monitor and enter the associated critical section. Likewise, to “exit” a monitor means to release ownership of the monitor and exit the critical section. We also say that a thread that has locked a monitor now “owns” that monitor. “Uncontended” refers to synchronization operations on an otherwise unowned monitor by only a single thread.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The HotSpot VM incorporates leading-edge techniques for both uncontended and contended synchronization operations which boost synchronization performance by a large factor.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Uncontended synchronization operations, which comprise the majority of synchronizations, are implemented with constant-time techniques. With</span><i><span style="font-size: 10pt;">biased locking</span></i><span style="font-size: 10pt;">, in the best case these operations are essentially free of cost. Since most objects are locked by at most one thread during their lifetime, we allow that thread to</span><em><span style="font-size: 10pt;">bias</span></em><span style="font-size: 10pt;">an object toward itself. Once biased, that thread can subsequently lock and unlock the object without resorting to expensive atomic instructions.[7]</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Contended synchronization operations use advanced adaptive spinning techniques to improve throughput even for applications with significant amounts of lock contention. As a result, synchronization performance becomes so fast that it is not a significant performance issue for the vast majority of real-world programs.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">In HotSpot, most synchronization is handled through what we call ””fast-path” code. We have two just-in-time compilers (JITs) and an interpreter, all of which will emit fast-path code. The two JITs are “C1”, which is the</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-client</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">compiler, and “C2”, which is the</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-server</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">compiler. C1 and C2 both emit fast-path code directly at the synchronization site. In the normal case when there's no contention, the synchronization operation will be completed entirely in the fast-path. If, however, we need to block or wake a thread (in monitorenter or monitorexit, respectively), the fast-path code will call into the slow-path. The slow-path implementation is in native C++ code while the fast-path is emitted by the JITs.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Per-object synchronization state is encoded in the first word (the so-called</span><i><span style="font-size: 10pt;">mark word</span></i><span style="font-size: 10pt;">) of the VM's object representation. For several states, the mark word is multiplexed to point to additional synchronization metadata. (As an aside, in addition, the mark word is also multiplexed to contain GC age data, and the object's identity hashCode value.) The states are:</span></span></p>
<ul style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;padding-left:2em;list-style-type:square;">
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Neutral: Unlocked</span></span></dt>
</dl>
</li>
<li value="1" style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Biased: Locked/Unlocked + Unshared</span></span></dt>
</dl>
</li>
<li value="1" style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Stack-Locked: Locked + Shared but uncontended</span><br/>
<span style="font-size: 10pt;">The mark points to displaced mark word on the owner thread's stack.</span></span></dt>
</dl>
</li>
<li value="1" style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Inflated: Locked/Unlocked + Shared and contended</span><br/>
<span style="font-size: 10pt;">Threads are blocked in monitorenter or wait().</span><br/>
<span style="font-size: 10pt;">The mark points to heavy-weight "objectmonitor" structure.[8]</span></span></dt>
</dl>
</li>
</ul>
<h3 style="font-size:9pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Thread Management</span></h3>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Thread management covers all aspects of the thread lifecycle, from creation through to termination, and the coordination of threads within the VM. This involves management of threads created from Java code (whether application code or library code), native threads that attach directly to the VM, or internal VM threads created for a range of purposes. While the broader aspects of thread management are platform independent, the details necessarily vary depending on the underlying operating system.</span></span></p>
<h4 style="font-size:8pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Threading Model</span></h4>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The basic threading model in Hotspot is a 1:1 mapping between Java threads (an instance of</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">) and native operating system threads. The native thread is created when the Java thread is started, and is reclaimed once it terminates. The operating system is responsible for scheduling all threads and dispatching to any available CPU.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The relationship between Java thread priorities and operating system thread priorities is a complex one that varies across systems. These details are covered later.</span></span></p>
<h4 style="font-size:8pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Thread Creation and Destruction</span></h4>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">There are two basic ways for a thread to be introduced into the VM: execution of Java code that calls</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">start()</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">on a</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">object; or attaching an existing native thread to the VM using JNI. Other threads created by the VM for internal purposes are discussed below.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">There are a number of objects associated with a given thread in the VM (remembering that Hotspot is written in the C++ object-oriented programming language):</span></span></p>
<ul style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;padding-left:2em;list-style-type:square;">
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">instance that represents a thread in Java code</span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">A</span></span><font face="Courier New, monospace"><font size="3">JavaThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">instance that represents the</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">instance inside the VM. It contains additional information to track the state of the thread. A</span></span><font face="Courier New, monospace"><font size="3">JavaThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">holds a reference to its associated</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">object (as an</span></span><font face="Courier New, monospace"><font size="3">oop</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">), and the</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">object also stores a reference to its</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">JavaThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">(as a raw</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">int</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">). A</span></span><font face="Courier New, monospace"><font size="3">JavaThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">also holds a reference to its associated</span></span><font face="Courier New, monospace"><font size="3">OSThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">instance.</span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">An</span></span><font face="Courier New, monospace"><font size="3">OSThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">instance represents an operating system thread, and contains additional operating-system-level information needed to track thread state. The</span></span><font face="Courier New, monospace"><font size="3">OSThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">then contains a platform specific “handle” to identify the actual thread to the operating system</span></span></dt>
</dl>
</li>
</ul>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">When a</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">is started the VM creates the associated</span></span><font face="Courier New, monospace"><font size="3">JavaThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">and</span></span><font face="Courier New, monospace"><font size="3">OSThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">objects, and ultimately the native thread. After preparing all of the VM state (such as thread-local storage and allocation buffers, synchronization objects and so forth) the native thread is started. The native thread completes initialization and then executes a start-up method that leads to the execution of the</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">object's</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">run()</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">method, and then, upon its return, terminates the thread after dealing with any uncaught exceptions, and interacting with the VM to check if termination of this thread requires termination of the whole VM. Thread termination releases all allocated resources, removes the</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">JavaThread</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">from the set of known threads, invokes destructors for the</span></span><font face="Courier New, monospace"><font size="3">OSThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">and</span></span><font face="Courier New, monospace"><font size="3">JavaThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">and ultimately ceases execution when it's initial startup method completes.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">A native thread attaches to the VM using the JNI call</span></span><font face="Courier New, monospace"><font size="3">AttachCurrentThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">. In response to this an associated</span></span><font face="Courier New, monospace"><font size="3">OSThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">and</span></span><font face="Courier New, monospace"><font size="3">JavaThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">instance is created and basic initialization is performed. Next a</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">object must be created for the attached thread, which is done by reflectively invoking the Java code for the</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">class constructor, based on the arguments supplied when the thread attached. Once attached, a thread can invoke whatever Java code it needs to via the other JNI methods available. Finally when the native thread no longer wishes to be involved with the VM it can call the JNI</span></span><font face="Courier New, monospace"><font size="3">DetachCurrentThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">method to disassociate it from the VM (release resources, drop the reference to the</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">instance, destruct the</span></span><font face="Courier New, monospace"><font size="3">JavaThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">and</span></span><font face="Courier New, monospace"><font size="3">OSThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">objects and so forth).</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">A special case of attaching a native thread is the initial creation of the VM via the JNI</span></span><font face="Courier New, monospace"><font size="3">CreateJavaVM</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">call, which can be done by a native application or by the launcher (</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">java.c</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">). This causes a range of initialization operations to take place and then acts effectively as if a call to</span></span><font face="Courier New, monospace"><font size="3">AttachCurrentThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">was made. The thread can then invoke Java code as needed, such as reflective invocation of the</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">main</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">method of an application. See the JNI section for further details.</span></span></p>
<h4 style="font-size:8pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Thread States</span></h4>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The VM uses a number of different internal thread states to characterize what each thread is doing. This is necessary both for coordinating the interactions of threads, and for providing useful debugging information if things go wrong. A thread's state transitions as different actions are performed, and these transition points are used to check that it is appropriate for a thread to proceed with the requested action at that point in time – see the discussion of safepoints below.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The main thread states from the VM perspective are as follows:</span></span></p>
<ul style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;padding-left:2em;list-style-type:square;">
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><font face="Courier New, monospace"><font size="3"><span style="text-decoration:none;">_thread_new</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">: a new thread in the process of being initialized</span></span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><font face="Courier New, monospace"><font size="3"><span style="text-decoration:none;">_thread_in_Java</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">: a thread that is executing Java code</span></span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><font face="Courier New, monospace"><font size="3"><span style="text-decoration:none;">_thread_in_vm</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">: a thread that is executing inside the VM</span></span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><font face="Courier New, monospace"><font size="3"><span style="text-decoration:none;">_thread_blocked</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">: the thread is blocked for some reason (acquiring a lock, waiting for a condition, sleeping, performing a blocking I/O operation and so forth)</span></span></span></dt>
</dl>
</li>
</ul>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">For debugging purposes additional state information is also maintained for reporting by tools, in thread dumps, stack traces etc. This is maintained in the</span></span></span><font face="Courier New, monospace"><font size="3"><span style="text-decoration:none;">OSThread</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">and some of it has fallen into dis-use, but states reported in thread dumps etc include:</span></span></span></p>
<ul style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;padding-left:2em;list-style-type:square;">
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><font face="Courier New, monospace"><font size="3"><span style="text-decoration:none;">MONITOR_WAIT</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">: a thread is waiting to acquire a contended monitor lock</span></span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><font face="Courier New, monospace"><font size="3"><span style="text-decoration:none;">CONDVAR_WAIT</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">: a thread is waiting on an internal condition variable used by the VM (not associated with any Java level object)</span></span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><font face="Courier New, monospace"><font size="3"><span style="text-decoration:none;">OBJECT_WAIT</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">: a thread is performing an</span></span></span><font face="Courier New, monospace"><font size="3"><span style="text-decoration:none;">Object.wait()</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">call</span></span></span></dt>
</dl>
</li>
</ul>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">Other subsystems and libraries impose their own state information, such as the JVMTI system and the</span></span></span><font face="Courier New, monospace"><font size="3"><span style="text-decoration:none;">ThreadState</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">exposed by the</span></span></span><font face="Lucida Sans Typewriter, monospace"><font size="3"><span style="text-decoration:none;">java.lang.Thread</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="text-decoration:none;"><span style="font-size: 10pt;">class itself. Such information is generally not accessible to, nor relevant to, the management of threads inside the VM.</span></span></span></p>
<h4 style="font-size:8pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Internal VM Threads</span></h4>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">People are often surprised to discover that even executing a simple “Hello World” program can result in the creation of a dozen or more threads in the system. These arise from a combination of internal VM threads, and library related threads (such as reference handler and finalizer threads). The main kinds of VM threads are as follows:</span></span></p>
<ul style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;padding-left:2em;list-style-type:square;">
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">VM thread: This singleton instance of</span></span><font face="Courier New, monospace"><font size="3">VMThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">is responsible for executing VM operations, which are discussed below</span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Periodic task thread: This singleton instance of</span></span><font face="Courier New, monospace"><font size="3">WatcherThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">simulates timer interrupts for executing periodic operations within the VM</span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">GC threads: These threads, of different types, support parallel and concurrent garbage collection</span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Compiler threads: These threads perform runtime compilation of bytecode to native code</span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Signal dispatcher thread: This thread waits for process directed signals and dispatches them to a Java level signal handling method</span></span></dt>
</dl>
</li>
</ul>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">All threads are instances of the</span></span><font face="Courier New, monospace"><font size="3">Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">class, and all threads that execute Java code are</span></span><font face="Courier New, monospace"><font size="3">JavaThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">instances (a subclass of</span></span><font face="Courier New, monospace"><font size="3">Thread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">). The VM keeps track of all threads in a linked-list known as the</span></span><font face="Courier New, monospace"><font size="3">Threads_list</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">, and which is protected by the</span></span><font face="Courier New, monospace"><font size="3">Threads_lock</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">– one of the key synchronization locks used within the VM.</span></span></p>
<h4 style="font-size:8pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">VM Operations and Safepoints</span></h4>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The</span></span><font face="Courier New, monospace"><font size="3">VMThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">spends its time waiting for operations to appear in the</span></span><font face="Courier New, monospace"><font size="3">VMOperationQueue</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">, and then executing those operations. Typically these operations are passed on to the</span></span><font face="Courier New, monospace"><font size="3">VMThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">because they require that the VM reach a</span><i><span style="font-size: 10pt;">safepoin</span></i><span style="font-size: 10pt;">t before they can be executed. In simple terms, when the VM is at safepoint all threads inside the VM have been blocked, and any threads executing in native code are prevented from returning to the VM while the safepoint is in progress. This means that the VM operation can be executed knowing that no thread can be in the middle of modifying the Java heap, and all threads are in a state such that their Java stacks are unchanging and can be examined.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The most familiar VM operation is for garbage collection, or more specifically for the “stop-the-world” phase of garbage collection that is common to many garbage collection algorithms. But many other safepoint based VM operations exist, for example: biased locking revocation, thread stack dumps, thread suspension or stopping (i.e. The</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">java.lang.Thread.stop()</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">method) and numerous inspection/modification operations requested through JVMTI.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Many VM operations are synchronous, that is the requestor blocks until the operation has completed, but some are asynchronous or concurrent, meaning that the requestor can proceed in parallel with the</span></span><font face="Courier New, monospace"><font size="3">VMThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">(assuming no safepoint is initiated of course).</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Safepoints are initiated using a cooperative, polling-based mechanism. In simple terms, every so often a thread asks “should I block for a safepoint?”. Asking this question efficiently is not so simple. One place where the question is often asked is during a thread state transition. Not all state transitions do this, for example a thread leaving the VM to go to native code, but many do. The other places where a thread asks are in compiled code when returning from a method or at certain stages during loop iteration. Threads executing interpreted code don't usually ask the question, instead when the safepoint is requested the interpreter switches to a different dispatch table that includes the code to ask the question; when the safepoint is over, the dispatch table is switched back again. Once a safepoint has been requested, the</span></span><font face="Courier New, monospace"><font size="3">VMThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">must wait until all threads are known to be in a safepoint-safe state before proceeding to execute the VM operation. During a safepoint the</span></span><font face="Courier New, monospace"><font size="3">Threads_lock</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">is used to block any threads that were running, with the</span></span><font face="Courier New, monospace"><font size="3">VMThread</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">finally releasing the</span></span><font face="Courier New, monospace"><font size="3">Threads_lock</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">after the VM operation has been performed.</span></span></p>
<h3 style="font-size:9pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">C++ Heap Management</span></h3>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">In addition to the Java heap, which is maintained by the Java heap manager and garbage collectors, HotSpot also uses the C/C++ heap (also called the malloc heap) for storage of VM-internal objects and data. A set of C++ classes derived from the base class</span></span><font face="Courier New, monospace"><font size="3"><i>Arena</i></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">is used to manage C++ heap operations.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><font face="Courier New, monospace"><font size="3">Arena</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">and its subclasses provide a fast allocation layer that sits on top of malloc/free. Each</span></span><font face="Courier New, monospace"><font size="3">Arena</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">allocates memory blocks (or</span></span><font face="Courier New, monospace"><font size="3"><i>Chunks</i></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><i><span style="font-size: 10pt;">)</span></i><span style="font-size: 10pt;">out of 3 global</span></span><font face="Courier New, monospace"><font size="3"><i>ChunkPool</i></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><i><span style="font-size: 10pt;">s.</span></i><span style="font-size: 10pt;">Each</span></span><font face="Courier New, monospace"><font size="3">ChunkPool</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">satisfies allocation requests for a distinct range of allocation sizes. For example, a request for 1k of memory will be allocated from the “small”</span></span><font face="Courier New, monospace"><font size="3">ChunkPool</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">, while a 10K allocation will be made from the "medium"</span></span><font face="Courier New, monospace"><font size="3">ChunkPool</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">. This is done to avoid wasteful memory fragmentation.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The</span></span><font face="Courier New, monospace"><font size="3">Arena</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">system also provides better performance than pure malloc/free. The latter operations may require acquisition of global OS locks, which affects scalability and can hurt performance.</span></span><font face="Courier New, monospace"><font size="3">Arena</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">s are thread-local objects which cache a certain amount of storage, so that in the fast-path allocation case a lock is not required. Likewise,</span></span><font face="Courier New, monospace"><font size="3">Arena</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">free operations do not require a lock in the common case.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><font face="Courier New, monospace"><font size="3">Arena</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">s are used for thread-local resource management (</span></span><font face="Courier New, monospace"><font size="3"><i>ResourceArea</i></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">) and handle management (</span></span><font face="Courier New, monospace"><font size="3"><i>HandleArea</i></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">). They are also used by both the client and server compilers during compilation.</span></span></p>
<h3 style="font-size:9pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Java Native Interface (JNI)</span></h3>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The JNI is a native programming interface. It allows Java code that runs inside a Java virtual machine to interoperate with applications and libraries written in other programming languages, such as C, C++, and assembly.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">While applications can be written entirely in Java, there are situations where Java alone does not meet the needs of an application. Programmers use the JNI to write</span><em><span style="font-size: 10pt;">Java native methods</span></em><span style="font-size: 10pt;">to handle those situations when an application cannot be written entirely in Java.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">JNI native methods can be used to create, inspect, and update Java objects, call Java methods, catch and throw exceptions, load classes and obtain class information, and perform runtime type checking.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The JNI may also be used with the</span><em><span style="font-size: 10pt;">Invocation API</span></em><span style="font-size: 10pt;">to enable an arbitrary native application to embed the Java VM. This allows programmers to easily make their existing applications Java-enabled without having to link with the VM source code. [9]</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><font size="3">It is important to remember that once an application uses the JNI, it risks losing two benefits of the Java platform.</font></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">First, Java applications that depend on the JNI can no longer readily run on multiple host environments. Even though the part of an application written in the Java programming language is portable to multiple host environments, it will be necessary to recompile the part of the application written in native programming languages.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Second, while the Java programming language is type-safe and secure, native languages such as C or C++ are not. As a result, Java developers must use extra care when writing applications using the JNI. A misbehaving native method can corrupt the entire application. For this reason, Java applications are subject to security checks before invoking JNI features.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><font size="3">As a general rule, developers should architect the application so that native methods are defined in as few classes as possible. This entails a cleaner isolation between native code and the rest of the application.[10]</font></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><font size="3">In HotSpot, the implementation of the JNI functions is relatively straightforward. It uses various VM internal primitives to perform activities such as object creation, method invocation, etc. In general, these are the same runtime primitives used by other subsystems such as the interpreter.</font></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">A command line option,</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-Xcheck:jni</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">, is provided to aid in debugging problems in JNI usage by native methods. Specifying</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-Xcheck:jni</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">causes an alternate set of debugging interfaces to be used by JNI calls. The alternate interface verifies arguments to JNI calls more stringently, as well as performing additional internal consistency checks.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">HotSpot must take special care to keep track of which threads are currently executing in native methods. During some VM activities, notably some phases of garbage collection, one or more threads must be halted at a</span><i><span style="font-size: 10pt;">safepoint</span></i><span style="font-size: 10pt;">in order to guarantee that the Java memory heap is not modified during the sensitive activity. When we wish to bring a thread executing in native code to a safepoint, it is allowed to continue executing native code, but the thread will be stopped when it attempts to return into Java code or make a JNI call.</span></span></p>
<h3 style="font-size:9pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">VM Fatal Error Handling</span></h3>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">It is very important to provide easy ways to handle fatal errors for any software. Java Virtual Machine, i.e. JVM is not an exception. A typical fatal error would be</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">OutOfMemoryError</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">. Another common fatal error on Windows is called</span></span><font face="Courier New, monospace"><font size="3">Access Violation</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">error which is equivalent to</span></span><font face="Courier New, monospace"><font size="3">Segmentation Fault</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">on Solaris/Linux platforms. It is critical to understand the cause of these kind of fatal errors in order to fix them either in your application or sometimes, in JVM itself.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Usually when JVM crashes on a fatal error, it will dump a hotspot error log file called</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">hs_err_pid</span></font><font face="Courier New, monospace"><i><span style="font-size: 10pt;">&lt;pid></span></i></font><font face="Courier New, monospace"><span style="font-size: 10pt;">.log</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">, (where</span></span><font face="Courier New, monospace"><i><span style="font-size: 10pt;">&lt;pid></span></i></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">is replaced by the crashed java process id) to the Windows desktop or the current application directory on Solaris/Linux. Several enhancements have been made to improve the diagnosability of this file since JDK 6 and many of them have been back ported to the JDK-1.4.2_09 release. Here are some highlights of these improvements:</span></span></p>
<ul style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;padding-left:2em;list-style-type:square;">
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Memory map is included in the error log file so it is easy to see how memory was laid out during crash.</span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><font face="Courier New, monospace"><span style="font-size: 10pt;">-XX:ErrorFile=</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">option is provided so that user can set the path name of the error log file.</span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><font face="Lucida Sans Typewriter, monospace"><font size="3">OutOfMemoryError</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">will trigger the file to be generated as well.</span></span></dt>
</dl>
</li>
</ul>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Another important feature is you can specify</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-XX:OnError=</span><font face="Courier New, monospace"><span style="font-size: 10pt;">"</span></font><font face="Courier New, monospace"><i><span style="font-size: 10pt;">cmd1 args...;com2 ...</span></i></font><span style="font-size: 10pt;">"</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">to the java command so that whenever VM crashes, it will execute a list of commands you specified within the quotes shown above. A typical usage of this feature is you can invoke the debugger such as dbx or Windbg to look into the crash when that happens. For the earlier releases, you can specify</span><br/></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-XX:+ShowMessageBoxOnError</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">as a runtime option so that when VM crashes, you can attach the running Java process to your favorite debugger.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Having said something about HotSpot error log files, here is a brief summary on how JVM internally handles fatal errors.</span></span></p>
<ul style="margin-top:1ex;margin-bottom:1ex;margin-right:2em;padding-left:2em;list-style-type:square;">
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The</span></span><font face="Courier New, monospace"><font size="3">VMError</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">class was invented for aggregating and dumping the</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">hs_err_pid</span></font><font face="Courier New, monospace"><i><span style="font-size: 10pt;">&lt;pid></span></i></font><font face="Courier New, monospace"><span style="font-size: 10pt;">.log</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">file. It is invoked by the OS-specific code when an unrecognized signal/exception is seen.</span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The VM uses signals internally for communication. The fatal error handler is invoked when the signal is not recognized. In the unrecognized case, it may come from a fault in application JNI code, OS native libraries, JRE native libraries, or the JVM itself.</span></span></dt>
</dl>
</li>
<li style="margin-top:0pt;margin-bottom:0pt;">
<dl>
<dt><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">The fatal error handler was carefully written to avoid causing faults itself, in the case of</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">StackOverflow</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">or crashes when critical locks are held (like malloc lock).</span></span></dt>
</dl>
</li>
</ul>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Since</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">OutOfMemoryError</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">is so common to some large scale applications, it is critical to provide useful diagnostic message to users so that they could quickly identify a solution, sometimes by just specifying a larger Java heap size. When</span></span><font face="Lucida Sans Typewriter, monospace"><font size="3">OutOfMemoryError</font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">happens, the error message will indicate which type of memory is problematic. For example, it could be Java heap space or PermGen space etc. Since JDK 6, a stack trace will be included in the error message. Also,</span><br/></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-XX:OnOutOfMemoryError=</span><font face="Courier New, monospace"><span style="font-size: 10pt;">"</span></font><font face="Courier New, monospace"><i><span style="font-size: 10pt;">&lt;cmd></span></i></font><font face="Courier New, monospace"><span style="font-size: 10pt;">"</span></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">option was invented so that a command will be run when the first OutOfMemoryError is thrown. Another nice feature that is worth mentioning is a built-in heap dump at OutOfMemoryError. It is enabled by specifying</span></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-XX:+HeapDumpOnOutOfMemoryError</span></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">option and you can also tell the VM where to put the heap dump file by specifying</span><br/></span><font face="Courier New, monospace"><span style="font-size: 10pt;">-XX:HeapDumpPath=</span><font face="Courier New, monospace"><i><span style="font-size: 10pt;">&lt;pathname></span></i></font></font><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">Even though applications are carefully written to avoid deadlocks, sometimes it still happens. When deadlock occurs, you can type “Ctrl+Break” on Windows or grab the Java process id and send SIGQUIT to the hang process on Solaris/Linux. A Java level stack trace will be dumped out to the standard out so that you can analyze the reasons of deadlock. Since JDK 6, this feature has been built into jconsole which is a very useful tool in the JDK. So when the application hangs on a deadlock, use jconsole to attach the process and it will analyze which lock is problematic. Most of the time, the deadlock is caused by acquiring locks in the wrong order.</span></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">We strongly encourage you to check out the “Trouble-Shooting and Diagnostic Guide”[11]. It contains a lot of information which might be very useful to diagnose fatal errors.</span></span></p>
<h3 style="font-size:9pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">Further Reading</span></h3>
<p style="padding:0pt;margin:1ex 0em;margin-bottom:0in;widows:0;orphans:0;page-break-before:auto;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">“Resolving the Mysteries of Java SE Classloader”, Jeff Nisewanger, Karen Kinnear, JavaOne 2006.</span></span></p>
<h3 style="font-size:9pt;font-weight:bold;padding:0pt;margin:1.5ex 0pt 1ex;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;">References</span></h3>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">[1] Java Language Specification, Third Edition. Gosling, Joy, Steele, Bracha.</span><a href="http://java.sun.com/docs/books/jls/third_edition/html/execution.html#12.2" style="text-decoration:none;color:rgb(67, 114, 145);"><span style="font-size: 10pt;">http://java.sun.com/docs/books/jls/third_edition/html/execution.html#12.2</span></a></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">[2] Java Virtual Machine Specification, Second Edition. Tim Lindholm, Frank Yellin.</span><a href="http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html" style="text-decoration:none;color:rgb(67, 114, 145);"><span style="font-size: 10pt;">http://java.sun.com/docs/books/vmspec/2nd-edition/html/VMSpecTOC.doc.html</span></a></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">[3] Amendment to Java Virtual Machine Specification. Chapter 5: Loading, Linking and Initializing.</span><a href="http://java.sun.com/docs/books/vmspec/2nd-edition/ConstantPool.pdf" style="text-decoration:none;color:rgb(67, 114, 145);"><span style="font-size: 10pt;">http://java.sun.com/docs/books/vmspec/2nd-edition/ConstantPool.pdf</span></a></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">[4] Dynamic Class Loading in the Java Virtual Machine. Shen Liang, Gilad Bracha. Proc. of the ACM Conf. on Object-Oriented Programming, Systems, Languages and Applications, October 1998</span><a href="http://www.bracha.org/classloaders.ps" style="text-decoration:none;color:rgb(67, 114, 145);"><span style="font-size: 10pt;">http://www.bracha.org/classloaders.ps</span></a></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">[5] “Safe Clsss and Data Evolution in Large and Long-Lived Java Applications”, Mikhail Dmitriev,</span><a href="http://research.sun.com/techrep/2001/smli_tr-2001-98.pdf" style="text-decoration:none;color:rgb(67, 114, 145);"><span style="font-size: 10pt;">http://research.sun.com/techrep/2001/smli_tr-2001-98.pdf</span></a></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">[6] Java Language Specification, Third Edition. Gosling, Joy, Steele, Bracha.</span><a href="http://java.sun.com/docs/books/jls/third_edition/html/exceptions.html" style="text-decoration:none;color:rgb(67, 114, 145);"><span style="font-size: 10pt;">http://java.sun.com/docs/books/jls/third_edition/html/exceptions.html</span></a></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">[7] “Biased Locking in HotSpot”.</span><a href="http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot" style="text-decoration:none;color:rgb(67, 114, 145);"><span style="font-size: 10pt;">http://blogs.oracle.com/dave/entry/biased_locking_in_hotspot</span></a></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">[8] “Let’s say you’re interested in using HotSpot as a vehicle for synchronization research ...”.</span><a href="http://blogs.oracle.com/dave/entry/lets_say_you_re_interested" style="text-decoration:none;color:rgb(67, 114, 145);"><span style="font-size: 10pt;">http://blogs.oracle.com/dave/entry/lets_say_you_re_interested</span></a></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">[9] “Java Native Interface Specifications”</span><a href="http://java.sun.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html" style="text-decoration:none;color:rgb(67, 114, 145);"><span style="font-size: 10pt;">http://java.sun.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html</span></a></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">[10] “The Java Native Interface Programmer’s Guide and Specification”, Sheng Liang,</span><a href="http://java.sun.com/docs/books/jni/html/titlepage.html" style="text-decoration:none;color:rgb(67, 114, 145);"><span style="font-size: 10pt;">http://java.sun.com/docs/books/jni/html/titlepage.html</span></a></span></p>
<p style="padding:0pt;margin:1ex 0em;"><span style="font-family: 'DejaVu Sans', 'Bitstream Vera Sans', 'Luxi Sans', Verdana, Arial, Helvetica;"><span style="font-size: 10pt;">[11] “Trouble-Shooting and Diagnostic Guide”</span><a href="http://java.sun.com/javase/6/webnotes/trouble/" style="text-decoration:none;color:rgb(67, 114, 145);"><span style="font-size: 10pt;">http://java.sun.com/javase/6/webnotes/trouble/</span></a></span></p>
</div>
<div><br/></div>
</body></html>
